<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jungle Runner Pro: Fixed Streak Edition</title>
    <style>
        body { margin: 0; background: #000; color: white; font-family: sans-serif; overflow: hidden; touch-action: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; }
        canvas { background: #2c3e50; }
        #ui { position: absolute; top: 15px; left: 15px; pointer-events: none; z-index: 10; }
        #word-prompt { 
            position: absolute; top: 10%; width: 100%; text-align: center; 
            font-size: 38px; font-weight: bold; color: #f1c40f; z-index: 10;
            text-shadow: 2px 2px 10px rgba(0,0,0,0.8);
        }
        #announcement {
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 60px; color: #ff3333; font-weight: bold; display: none;
            text-shadow: 0 0 20px rgba(255,0,0,0.7); z-index: 20;
        }
        #file-overlay {
            position: absolute; width: 100%; height: 100%; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100;
        }
        .stat { font-size: 20px; margin-bottom: 5px; font-weight: bold; }
        .hidden { display: none !important; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .blinking { animation: blink 0.5s infinite; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="file-overlay">
        <h1>üå≥ JUNGLE RUNNER PRO</h1>
        <p>T·∫£i file .txt ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
        <input type="file" id="fileInput" accept=".txt">
    </div>

    <div id="ui" class="hidden">
        <div class="stat">Th·ªùi gian: <span id="timer">00:00</span></div>
        <div class="stat">M·∫°ng: <span id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
        <div class="stat">Chu·ªói hi·ªán t·∫°i: <span id="streak">0</span></div>
        <div class="stat" id="speed-tag">T·ªëc ƒë·ªô: x2.0</div>
    </div>
    <div id="word-prompt"></div>
    <div id="announcement" class="blinking">WATCH OUT!</div>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('fileInput');
const wordPrompt = document.getElementById('word-prompt');
const announcement = document.getElementById('announcement');

const playerImg = new Image(); playerImg.src = 'car1.png';
const enemyImg = new Image(); enemyImg.src = 'car2.png';
const bgImg = new Image(); bgImg.src = 'bg.png';

const LANE_WIDTH = 130;
const CANVAS_WIDTH = LANE_WIDTH * 3;
const LANES = [LANE_WIDTH * 0.5, LANE_WIDTH * 1.5, LANE_WIDTH * 2.5];

let pairs = [], currentPair = null;
let lives = 3, streak = 0, maxStreak = 0, pairsAnswered = 0, gameState = 'START';
let baseSpeed = 6, difficultyMult = 2.0, gameSpeed = 0;
let isSlowMo = false, isCooldown = false, isConfirming = false;
let lastQuestionTime = 0, shakeTime = 0, cooldownEndTime = 0;
let startTime = 0, timerInterval = null;

let bgY = 0;
const player = { lane: 1, x: LANES[1], y: 0, w: 60, h: 100, flickerTimer: 0 };
let objects = [], speedLines = [];

for(let i=0; i<15; i++) speedLines.push({ x: Math.random()*CANVAS_WIDTH, y: Math.random()*800, l: 30, s: 15 });

function isTouchingPlayer(touchX, touchY) {
    const rect = canvas.getBoundingClientRect();
    const x = touchX - rect.left;
    const y = touchY - rect.top;
    return (x > player.x - 50 && x < player.x + 50 && y > player.y - 20 && y < player.y + 120);
}

window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') player.lane = Math.max(0, player.lane - 1);
    if (e.key === 'ArrowRight') player.lane = Math.min(2, player.lane + 1);
});

window.addEventListener('mousedown', e => { if (isTouchingPlayer(e.clientX, e.clientY)) isConfirming = true; });
window.addEventListener('mouseup', () => isConfirming = false);
window.addEventListener('contextmenu', e => e.preventDefault());

let touchStartX = 0;
window.addEventListener('touchstart', e => { 
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    if (isTouchingPlayer(touch.clientX, touch.clientY)) isConfirming = true;
}, {passive: false});

window.addEventListener('touchend', e => {
    isConfirming = false;
    let dx = e.changedTouches[0].clientX - touchStartX;
    if (Math.abs(dx) > 40) player.lane = Math.max(0, Math.min(2, player.lane + (dx > 0 ? 1 : -1)));
}, {passive: false});

fileInput.addEventListener('change', e => {
    const reader = new FileReader();
    reader.onload = (ev) => {
        const lines = ev.target.result.split(/\r?\n/).filter(l => l.trim() !== "");
        for (let i = 0; i < lines.length; i += 2) if (lines[i+1]) pairs.push({ a: lines[i], b: lines[i+1] });
        if (pairs.length > 0) startGame();
    };
    reader.readAsText(e.target.files[0]);
});

function startGame() {
    document.getElementById('file-overlay').classList.add('hidden');
    document.getElementById('ui').classList.remove('hidden');
    gameState = 'PLAYING';
    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 1000);
    resize();
    player.y = canvas.height - 150;
    lastQuestionTime = Date.now();
    requestAnimationFrame(gameLoop);
}

function updateTimer() {
    if (gameState !== 'PLAYING') return;
    let elapsed = Math.floor((Date.now() - startTime) / 1000);
    document.getElementById('timer').innerText = `${Math.floor(elapsed/60).toString().padStart(2,'0')}:${(elapsed%60).toString().padStart(2,'0')}`;
}

function spawnGates() {
    currentPair = pairs[Math.floor(Math.random() * pairs.length)];
    wordPrompt.innerText = `T√¨m: ${currentPair.a}`;
    isSlowMo = true;
    let correct = Math.floor(Math.random() * 3);
    let distractors = pairs.filter(p => p.b !== currentPair.b).map(p => p.b);
    for (let i = 0; i < 3; i++) {
        objects.push({
            type: 'GATE', lane: i, y: -400, h: 40,
            word: (i === correct) ? currentPair.b : (distractors.splice(Math.floor(Math.random()*distractors.length), 1)[0] || "..."),
            isCorrect: i === correct, hit: false
        });
    }
}

function update() {
    if (gameState !== 'PLAYING') return;

    let normalSpeed = baseSpeed * difficultyMult;
    if (isSlowMo) gameSpeed = isConfirming ? normalSpeed * 3 : 2.5; 
    else if (isCooldown) gameSpeed = normalSpeed * 0.7;
    else gameSpeed = isConfirming ? normalSpeed * 3 : normalSpeed;

    player.x += (LANES[player.lane] - player.x) * 0.2;
    bgY += gameSpeed;
    if (bgY >= canvas.height) bgY = 0;

    speedLines.forEach(l => {
        l.y += gameSpeed * 1.5;
        if (l.y > canvas.height) { l.y = -100; l.x = Math.random() * CANVAS_WIDTH; }
    });

    let now = Date.now();
    if (!isCooldown && objects.length === 0 && now - lastQuestionTime > 6000) {
        if (pairsAnswered > 0 && pairsAnswered % 10 === 0) {
            isCooldown = true; pairsAnswered = 0;
            cooldownEndTime = now + 10000;
            announcement.style.display = 'block';
            for(let i=0; i<6; i++) setTimeout(() => { if(isCooldown) objects.push({ type: 'CAR', lane: Math.floor(Math.random()*3), y: -150, w: 60, h: 100, hit: false }); }, i * 1400);
        } else spawnGates();
    }
    if (isCooldown && now > cooldownEndTime) { isCooldown = false; announcement.style.display = 'none'; lastQuestionTime = now; }

    objects.forEach((obj, i) => {
        obj.y += gameSpeed;
        if (obj.lane === player.lane && obj.y + (obj.h || 100) > player.y && obj.y < player.y + player.h && !obj.hit) {
            obj.hit = true;
            if (obj.type === 'GATE') {
                if (obj.isCorrect) { 
                    streak++; 
                    if (streak > maxStreak) maxStreak = streak; // C·∫≠p nh·∫≠t k·ª∑ l·ª•c
                    pairsAnswered++; 
                    if(pairsAnswered % 10 === 0) difficultyMult += 0.3;
                } else handleDamage();
                isSlowMo = false; wordPrompt.innerText = "";
                updateUI();
            } else { handleDamage(); objects.splice(i, 1); }
        }
    });
    objects = objects.filter(o => o.y < canvas.height + 200);
    if (player.flickerTimer > 0) player.flickerTimer -= 16;
}

function handleDamage() {
    lives--; 
    streak = 0; // Reset chu·ªói hi·ªán t·∫°i
    shakeTime = 30;
    player.flickerTimer = 2000;
    updateUI();
    if (lives <= 0) endGame();
}

function updateUI() {
    document.getElementById('lives').innerText = "‚ù§Ô∏è".repeat(lives);
    document.getElementById('streak').innerText = streak;
    document.getElementById('speed-tag').innerText = `T·ªëc ƒë·ªô: x${difficultyMult.toFixed(1)}`;
}

function draw() {
    let sx = (Math.random()-0.5)*shakeTime, sy = (Math.random()-0.5)*shakeTime;
    if (shakeTime > 0) shakeTime--;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save(); ctx.translate(sx, sy);

    // V·∫Ω Background
    const bgWidth = 120;
    ctx.drawImage(bgImg, 0, bgY - canvas.height, bgWidth, canvas.height);
    ctx.drawImage(bgImg, 0, bgY, bgWidth, canvas.height);
    ctx.save(); ctx.translate(CANVAS_WIDTH, 0); ctx.scale(-1, 1);
    ctx.drawImage(bgImg, 0, bgY - canvas.height, bgWidth, canvas.height);
    ctx.drawImage(bgImg, 0, bgY, bgWidth, canvas.height);
    ctx.restore();

    // V·∫Ω Objects
    objects.forEach(obj => {
        if (obj.type === 'GATE') {
            ctx.fillStyle = "#333"; ctx.fillRect(obj.lane * LANE_WIDTH + 10, obj.y, LANE_WIDTH - 20, obj.h);
            ctx.fillStyle = "#fff"; ctx.font = "bold 20px Arial"; ctx.textAlign = "center";
            ctx.fillText(obj.word, obj.lane * LANE_WIDTH + LANE_WIDTH/2, obj.y + obj.h + 35);
        } else {
            ctx.save(); ctx.translate(obj.lane * LANE_WIDTH + LANE_WIDTH/2, obj.y + obj.h/2);
            ctx.rotate(Math.PI); ctx.drawImage(enemyImg, -30, -50, 60, 100); ctx.restore();
        }
    });

    if (player.flickerTimer <= 0 || Math.floor(Date.now()/100)%2) ctx.drawImage(playerImg, player.x - 30, player.y, 60, 100);
    ctx.restore();
}

function resize() { canvas.height = window.innerHeight; canvas.width = CANVAS_WIDTH; }

function endGame() {
    clearInterval(timerInterval);
    gameState = 'END';
    const finalTime = document.getElementById('timer').innerText;
    // Hi·ªÉn th·ªã maxStreak thay v√¨ streak (v√¨ streak l√∫c n√†y ƒë√£ b·ªã reset v·ªÅ 0)
    alert(`TR√í CH∆†I K·∫æT TH√öC!\nTh·ªùi gian s·ªëng s√≥t: ${finalTime}\nChu·ªói k·ª∑ l·ª•c: ${maxStreak}`);
    location.reload();
}

function gameLoop() { update(); draw(); if (gameState === 'PLAYING') requestAnimationFrame(gameLoop); }
window.addEventListener('resize', resize);
resize();
</script>
</body>
</html>